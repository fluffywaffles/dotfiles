# vim: ft=zsh
alias ta='tmux attach'
alias pdf='mupdf'
alias open='xdg-open'
alias clip='xclip -sel clip'
#alias clip='pbcopy' # OS X
alias red="redshift"
alias vim='nvim'
alias svim='sudo -EP nvim'
alias clock="date +'%A %r'"
alias super='sudo -EPS' # upgrades current shell + env to superuser

alias l='ls -1'
alias ll='ls -lh'
alias la='ls -1A' # use -A not -a so that . and .. are omitted
alias lla='ls -lAh'

alias dd='dd status=progress'

alias mkpw="head -c512 /dev/urandom | sha512sum | cut -d' ' -f1"

#
# scanpdf
#
# use scanimage (SANE) to scan image, resize to lower ppi, convert to pdf,
# and output to target (${1}).
#
# ppi can be configured as an argument, as in:
#   scanpdf out.pdf ppi=100
# or as an environment variable, as in:
#   ppi=100 scanpdf out.pdf
#
function scanpdf () {(
  emulate -L zsh -e
  if [[ $# -lt 1 ]]; then
    echo $#
    >&2 printf 'ERR: missing: why no name for out pls?\n'
    return 1
  fi
  name="${1%%.pdf}"  # quoted: allow spaces in name
  ppi=${ppi:-50}; if [[ ${2} =~ "ppi=\d*" ]]; then
    ppi=(${(s:=:)2}) # convert to array splitting on '='
    ppi=${ppi[2]}    # select the number on right-hand side of '='
  elif [[ -n ${2} ]]; then
    >&2 printf 'ERR: bad arg: why u give bad ppi=N ??\n'
    return 1
  fi
  # intermediary files
  raw_pnm="${name}-raw.pnm"
  ppi_pnm="${name}-${ppi}ppi.pnm"
  intermediary_files=("${raw_pnm}" "${ppi_pnm}")
  # output file
  final_pdf="${name}.pdf"
  # scan, redraw, convert, clean up
  printf '◆ scan            (subsh)»  '
  (set -x; scanimage --format=pnm > "${raw_pnm}")
  printf '◆ redraw          (subsh)»  '
  (set -x; mutool draw -r "${ppi}" -o "${ppi_pnm}" "${raw_pnm}")
  printf '◆ convert to pdf  (subsh)»  '
  (set -x; mutool convert -O compress -o "${final_pdf}" "${ppi_pnm}")
  printf '◆ cleaning up     (subsh)»  '
  (set -x; rm "${intermediary_files[@]}")
)}

#
# zg
#
# z within the current git repository
#
function zg () {
  local root=$(git rev-parse --show-toplevel)
  [[ -n ${root} ]] && 2>&1 _z ${root} ${@}
}

#-------------------------------------------------------------------------
# the long git section
#-------------------------------------------------------------------------

#
# git-branch-current
#
# returns the local ref name for the currently checked-out HEAD
#
function git-branch-current () {(
  set -e
  git rev-parse --abbrev-ref HEAD
)}

#
# git-branch-upstream
#
# returns the remote ref name for the upstream configured for HEAD
#
function git-branch-upstream () {(
  set -e
  git rev-parse --abbrev-ref HEAD@{u}
)}

#
# git-push-set-upstream-branch-current
#
# pushes the current HEAD to a remote branch (${1}), setting upsteam to
# the remote branch (${1}). remote can be configured as a variable, as in:
#
#   remote=xyz gpu
#
# the positional argument for remote branch defaults to the current branch
# name; so, without arguments, this creates the local branch if it does
# not exist at the remote.
#
function git-push-set-upstream-branch-current () {(
  local branch=$(git rev-parse --abbrev-ref HEAD) # git-branch-current
  local remote=${remote:-origin}
  local remote_branch=${1:-${branch}}
  set -ex
  git push ${remote} --set-upstream ${remote_branch}
)}

#
# git-pull-rebase-origin-main
#
# rebase remote branch (${1}) from remote (${remote}) into the currently
# checked-out HEAD. remote can be configured as a variable, as in:
#
#   remote=xyz glom
#
# the positional argument defaults to the configured default branch name;
# that is:
#
#   git config init.defaultbranch
#
# this is often 'master', but can be altered in ${HOME}/.gitconfig.
#
function git-pull-rebase-origin-main () {(
  local branch=${1:-$(git config init.defaultbranch)}
  local remote=${remote:-origin}
  set -ex
  git pull --rebase ${remote} ${branch}
)}

#
# git-pull-rebase-then-force-with-lease-includes-origin-main
#
# rebase given remote branch (${1}) into current branch and then
# force-push to given remote branch (${2}) with lease. remote can be
# configured as a variable, as in:
#
#   remote=xyz glop
#
# positional arguments default to the currently checked-out HEAD.
#   ${1} selects a different remote branch to rebase into HEAD
#   ${2} selects a different remote branch for force-pushing-with-lease
#
# typical use-case is:
#   glop main
#
# this pulls-with-rebase from the mainline branch, then force-pushes to
# the upstream branch. in shorthand: "rebase main" on the remote.
#
# Nb. the use-case for using both arguments seems far-fetched, overall.
# most usages will just be `glop` or `glop main`, to rebase either the
# upstream or the mainline branch into the current branch and then push
# the new HEAD to the upstream.
#
function git-pull-rebase-then-force-with-lease-includes-origin-main () {(
  local upstream=$(git rev-parse --abbrev-ref HEAD@{u}) # git-branch-upstream
  local remote=${remote:-origin}
  local pull_branch=${1:-${upstream}}
  local push_branch=${2:-${upstream}}
  set -ex
  git pull --rebase ${remote} ${pull_branch}
  git push --force-with-lease --force-if-includes ${remote} ${push_branch}
)}

#
# git-push-current-branch
#
# push the currently checked-out HEAD to remote branch (${1}). remote can
# be configured as a variable, as in:
#
#   remote=xyz gpc
#
# supports passthrough flags, as in:
#
#   gpc --force-with-lease --force-if-includes
#
# the positional argument defaults to the current branch name.
#
# providing a different branch name does not change the local branch name,
# nor does it set an upstream; it just pushes to that name, on the remote.
#
function git-push-current-branch () {(
  local flags=() match mbegin mend
  while [[ ${1} =~ ^(-+[[:alnum:]]+)$ ]]; do shift; flags+=(${match}); done
  local branch=$(git rev-parse --abbrev-ref HEAD) # git-branch-current
  # named arguments
  local remote=${remote:-origin}
  # positional arguments
  local remote_branch=${1:-${branch}}
  set -ex
  git push ${flags[@]} ${remote} ${branch}:${remote_branch}
)}

#
# git-cd-toplevel
#
# change directory into the top-level directory of the current git repo.
#
function git-cd-toplevel () {
  local root=$(git rev-parse --show-toplevel)
  [[ -n "${root}" ]] && cd ${root}
}


#
# shell aliases for custom git functions
#
alias grt='git-cd-toplevel'
alias gbc='git-branch-current'
alias gpu='git-push-set-upstream-branch-current'
alias gpc='git-push-current-branch'
alias gpf='git-push-current-branch --force-with-lease --force-if-includes'
alias glom='git-pull-rebase-origin-main'
alias glop='git-pull-rebase-then-force-with-lease-includes-origin-main'

#
# shell aliases for common git commands
#
alias g='git'
alias ga='git add'
alias gb='git branch'
alias gc='git commit --verbose'
alias gd='git diff'
alias gf='git fetch'
alias gl='git pull'
alias gm='git merge --ff-only'
alias gp='git push'
alias gr='git rebase'
alias gs='git show'
alias gco='git checkout'
alias gfa='git fetch --all'
alias gst='git status'
alias gsq='git rebase --interactive --autosquash'
alias gdc='git diff --word-diff=color'
alias glog='git log --oneline --decorate --graph'
alias gloga='git log --oneline --decorate --graph --all'

#
# worktree setup aliases
#
alias gwa='git worktree add'
alias gwl='git worktree list'
alias gwm='git worktree move'
alias gwrm='git worktree remove'

#
# HOST-specific aliases [if any]
#
if [[ -s ~/.aliases.${HOST} ]]; then
  source ~/.aliases.${HOST}
fi
