#!/usr/bin/env -S zsh -euo pipefail

function git-worktree-root() {
  local worktree_list main_worktree commitish worktree_root_link
  local match mbegin mend # zsh regexp match variables set by =~

  # formatted error printing, if not [-]-s[ilent]
  local silent=${1}
  function eprintf { [[ ${silent} =~ ^-+s(ilent|)$ ]] || >&2 printf ${@} }

  # exit if not in a git directory
  local git_root=$(git rev-parse --show-toplevel)
  if ! git rev-parse --git-dir &>/dev/null; then return 0; fi

  # get the main worktree, which is the first result in the list
  git worktree list --porcelain | { read main_worktree; read commitish }
  # regex parse the worktree path
  [[ "${main_worktree}" =~ worktree\ ([^$'\n']+) ]]

  echo ${main_worktree} ${commitish}

  # error if the main worktree path is NOT a bare repository
  if ! [[ ${commitish} =~ ^bare$ ]]; then
    eprintf '!! ─ The main worktree is not a separate bare repository\n'
    return 1
  fi

  # now we know where our bare root is
  worktree_root_link="${match}/worktree-root"
  if ! [[ -L "${worktree_root_link}" ]]; then
    eprintf '!! ─ The bare worktree root has no `worktree-root` symlink\n'
    return 1
  fi

  printf '%s\n' $(readlink -e ${worktree_root_link})
}
