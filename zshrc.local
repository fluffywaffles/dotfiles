#
# Path!
# Djikstra! ... would be confused to know he is referenced here.
#

# Local bins come *first*
export PATH="$HOME/.local/bin:$PATH:$HOME/.cargo/bin"

#
# Keyboard
# QWERT
#

# Go it, fastly!
export KEYTIMEOUT=1

# Vi keybindings
bindkey -v

# Keybindings that should be preserved even after entering and exiting vi normal mode.
bindkey '^?' backward-delete-char
bindkey '^h' backward-delete-char
bindkey '^w' backward-kill-word

# Give me extended glob support
setopt extendedglob

# Don't share history between zsh sessions
setopt no_sharehistory

# ibus
export GTK_IM_MODULE=ibus  # youbus
export XMODIFIERS=@im=ibus # webus
export QT_IM_MODULE=ibus   # bus is life

#
# Aliases, functions, source-able software (plugins), ...?
#

# nvim pls
export EDITOR="nvim"

# Aliaseses
source ~/.aliases

# Better FZF (using ag for filtering)
export FZF_DEFAULT_COMMAND='ag -g ""'

# Add z
source $HOME/.local/zsh-functions/z/z.sh

#
# Battery functions (used below)
#

function batpower-setup {
  setopt +o nomatch # NOTE: suppress 'no match' error message
  local detected_batteries=$(ls -d /sys/class/power_supply/BAT* &>/dev/null)
  setopt -o nomatch
  local battery_listing=${BATPOWER_BATTERIES:-$detected_batteries}
  local batteries=()
  # NOTE: zsh: expansions don't perform word-splitting unless you use ${=...}
  for battery in ${=battery_listing}; do batteries+=($battery) done
  local battery_count=${#batteries}
  local selected_battery=''
  # If there are no batteries, fail.
  [[ $battery_count -eq 0 ]] && return 1
  # Otherwise, select the 1st battery.
  if [[ $battery_count -ge 1 ]]; then
    selected_battery=${batteries[1]}
    # When there's more than 1 battery, issue a notice
    if [[ $battery_count -gt 1 ]]; then
      printf 'batpower: multiple batteries detected! \n  %s\n' \
        "batteries=($batteries)"
    fi
  fi
  printf 'batpower: battery set: %s.\n' $selected_battery
  declare -g batpower_enabled=0
  declare -g batpower_battery_capacity_file="$selected_battery/capacity"
  declare -g batpower_battery_status_file="$selected_battery/status"
}

function batpower-enabled { return ${batpower_enabled:=1} }
function batpower-charge { batpower-enabled && cat $batpower_battery_capacity_file }
function batpower-status { batpower-enabled && cat $batpower_battery_status_file }
function batpower-fmt-charge { printf '%s%s' $1 '%%' }
function batpower-fmt-status {
  local status_symbol='?'
  case $1 in
    ( "Full" | "Unknown" ) status_symbol='▬';;
    ( "Charging"         ) status_symbol='▲';;
    ( "Discharging"      ) status_symbol='▼';;
  esac
  printf '%s▐' $status_symbol
}

function batpower-visual-battery {
  batpower-enabled || return 0
  local bat_charge=$(batpower-charge)
  local bat_status=$(batpower-status)
  local color=""
  if   [[ $bat_charge -ge 85 ]]; then
    color="$FG[118]" # green
  elif [[ $bat_charge -ge 50 ]]; then
    color="$FG[154]" # yellow-green
  elif [[ $bat_charge -ge 35 ]]; then
    color="$FG[011]" # yellow
  elif [[ $bat_charge -ge 20 ]]; then
    color="$FG[208]" # orange
  elif [[ $bat_charge -ge 00 ]]; then
    color="$FG[196]" # red
  fi
  printf "%s%s %s%s"                   \
    "%{${color}%}"                     \
    $(batpower-fmt-charge $bat_charge) \
    $(batpower-fmt-status $bat_status) \
    "%{$reset_color%}"
}

#
# Da PrompT
# λ λ λ
#

# Only do all this if we're in a decent terminal...
if [[ $TERM != "linux" ]]; then
  # Shorten the prompt
  # Stolen (!) from the "norm" zsh theme in OMZ
  printf -v PROMPT '%s %s%s%s '         \
    '%{$fg[yellow]%}▌ƒ▐'                \
    '%{$fg[green]%}%c'                  \
    '%{$fg[yellow]%}$(git_prompt_info)' \
    '%{$reset_color%}'
  ZSH_THEME_GIT_PROMPT_PREFIX=" ∙ %{$fg[red]%}"
  ZSH_THEME_GIT_PROMPT_SUFFIX=""
else
  printf -v PROMPT '%s %s%s%s '         \
    '%{$fg[yellow]%}f'                  \
    '%{$fg[green]%}%c'                  \
    '%{$fg[yellow]%}$(git_prompt_info)' \
    '%{$reset_color%}'
  ZSH_THEME_GIT_PROMPT_PREFIX=" . %{$fg[red]%}"
  ZSH_THEME_GIT_PROMPT_SUFFIX=""
fi

#
# RPrompT (the one on the right!)
# Print battery visual indicator and vim-mode on right-hand side of prompt
#

# NOTE: without this, there's space after the RPROMPT
ZLE_RPROMPT_INDENT=0
VIM_NORMAL_MODE="%{$FX[bold]$fg[blue]%}[nrm]%{$reset_color%}"
VIM_INSERT_MODE="%{$FX[bold]$fg[grey]%}[ins]%{$reset_color%}"

# Draw at start of each line print, and when keymap changes
function update-rprompt {
  printf -v RPROMPT '%s%s$EPS1'                                         \
    "${${KEYMAP/vicmd/$VIM_NORMAL_MODE}/(main|viins)/$VIM_INSERT_MODE}" \
    "${batpower_enabled:+ }$(batpower-visual-battery)"
}

# Widget functions (for when zsh redraws the prompt)
function zle-line-init zle-keymap-select {
  update-rprompt
  zle reset-prompt
}

# Register the widget functions
zle -N zle-line-init
zle -N zle-keymap-select

# Set up batpower and rprompt!
batpower-setup >/dev/null
update-rprompt

# Host-specific configuration
if [ -e $HOME/.zshrc.$(hostname) ]; then
  source $HOME/.zshrc.$(hostname)
fi

# Make ls colors consistent
export LS_COLORS="rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=0"
