#
# Keyboard
# QWERT
#

# Vi keybindings
bindkey -v

# Preserve keybindings even after entering and exiting vi normal mode.
bindkey '^?' backward-delete-char
bindkey '^h' backward-delete-char
bindkey '^w' backward-kill-word

#
# Aliases, functions, source-able software (plugins), ...?
#

# nvim pls
export EDITOR="nvim"

# Aliases
source ~/.aliases

# Load FZF
[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh

# Better FZF (using ag for filtering)
export FZF_DEFAULT_COMMAND='ag -g ""'

# Load z
source ${HOME}/.local/zsh-functions/z/z.sh

# Add cargo binaries to path (e.g. watchexec)
export path=(${HOME}/.cargo/bin ${path})

# Add select git-contrib binaries to path
export path=(
  /usr/share/git/diff-highlight
  ${path}
)

# Set configuration home directory for freedesktop user
export XDG_CONFIG_HOME="${HOME}/.config"

# Use neovim as Manpager
export MANPAGER="nvim +':Man!'"

# Report slow / high-memory commands AFTER running global and local setup
export REPORTMEMORY=100      # print timing stats for commands using >100k
export REPORTTIME=1          # print timing stats for commands taking >1s

#
# Prompt
#

vcs_prompt_formats=(
  '%{${fg[yellow]}%}${vcs[branch]:+ ∙ }'
  '%{${fg[9]}%}'
  '${vcs[branch]}${vcs[dirty]:+*}'
  '%{${fg[11]}%}${vcs[bare]:+ !bare}'
  '%{${fg[219]}%}${vcs[worktree_root]:+ @worktree/root}'
)

# Only use unicode if we're in a decent terminal...
if [[ ${TERM} != "linux" ]]; then
  printf -v PROMPT '%s %s%s%%{${reset_color}%%} ' \
    '%{$fg[yellow]%}▌ƒ▐'                          \
    '%{$fg[green]%}%c'                            \
    ${(j::)vcs_prompt_formats}
else
  printf -v PROMPT '%s %s%s%%{${reset_color}%%} ' \
    '%{$fg[yellow]%}f'                            \
    '%{$fg[green]%}%c'                            \
    ${(j::)vcs_prompt_formats}
fi

#
# RPrompt (the one on the right!)
# Print battery visual indicator and vim-mode on right-hand side of prompt
#

# Load batpower (for battery strength indicators in RPROMPT)
source ${HOME}/.local/zsh-functions/batpower.zsh

# Format string for conditionally displaying version control info
vcs_rprompt_formats+=(
  '${vcs[staged]:+[}'
  '%{${fg[blue]}%}${vcs[staged]:+staged}%{${reset_color}%}'
  '${vcs[staged]:+]}'
)

# Draw at start of each line print, and when keymap changes
uname=$(uname -s)
function update-rprompt {
  local match mbegin mend
  >/dev/null batpower-${uname:l}
  local normal="%{$fx[bold]$fg[blue]%}[nrm]%{$reset_color%}"
  local insert="%{$fx[bold]$fg[white]%}[ins]%{$reset_color%}"
  printf -v RPROMPT '%s%s%s${EPS1}'                     \
    ${(j::)vcs_rprompt_formats}                         \
    ${${KEYMAP/vicmd/${normal}}/(main|viins)/${insert}} \
    "${batpower_enabled:+ }$(batpower-visual-battery)"
    # ^ wrap in quotes to preserve spaces in the output
}

# Widget functions (for when zsh redraws the prompt)
function zle-line-init zle-keymap-select {
  update-rprompt
  zle reset-prompt
}

# Register the widget functions
zle -N zle-line-init
zle -N zle-keymap-select

# set up rprompt on load
update-rprompt

# Host-specific configuration and overrides
# This should come last so it can override e.g. REPORTTIME
if [ -e ${HOME}/.zshrc.${HOST} ]; then
  source ${HOME}/.zshrc.${HOST}
fi



#
#
#### WORKTREE MAGIC
#
#


# Autoload custom git functions
autoload git-worktree-root
alias gwr='git-worktree-root --verbose'
function gwk() { cd $(gwr) }

vcs-user__precmd() {
  if [[ -n ${vcs[bare]} ]] || [[ -z ${vcs[branch]} ]]; then
    return 0
  fi
  if [[ $(git-worktree-root) = ${PWD} ]]; then
    vcs[bare]=''
    vcs[worktree_root]=true
  fi
}

# function git-worktree-entries {
#   git worktree list --porcelain \
#     | grep -B2 'branch'         \
#     | grep -E 'branch|worktree' \
#     | sed -Ee 's\branch refs/heads/|worktree \\'
# }

function git-worktree-paths {
  typeset -A entries=($(git-worktree-entries))
  print ${(kj:\n:)entries}
}

# function git-worktree-branches {
#   typeset -A entries=($(git-worktree-entries))
#   print ${(vj:\n:)entries}
# }

# function git-branch-list-porcelain {
#   git show-ref --heads \
#     | sed -Ee 's\[0-9a-f]+ refs/heads/\\'
# }

#
# Taking advantage of the fact that there can only be one checked-out
# worktree per branch at any given time, find the worktree corresponding
# to the given branch (if any).
#
function git-worktree-find-for-branch {
  local branch=${1}
  typeset -A worktree_entries=($(git-worktree-entries))
  local index=${${(v)worktree_entries}[(i)${branch}]}
  local tree_path=${${(k)worktree_entries}[${index}]}
  print ${tree_path}
}

function git-worktree-create-if-not-exists {
  local match mbegin mend
  local branch=${1}
  # find existing worktree for branch, if any
  local tree_path=$(git-worktree-find-for-branch ${branch})
  if [[ -n ${tree_path} ]]; then
    print -nf '┯ %s\n└ %s\n'                  \
      "Worktree already exists for ${branch}" \
      "Path: ./${tree_path##$(git-worktree-root)/}"
    return 0
  fi
  # if no worktree exists, select a worktree path for it
  local target_path=${2:-$(git-worktree-default-branch-path ${branch})}
  # find an existing branch, whether local or remote
  local extant_branches=($(git-branch-list-porcelain --all))
  local existing=${extant_branches[(r)*${branch}]}
  local remotes=($(git remote))
  # build the argument list for 'git-worktree add'
  local -a args
  # if the existing branch points to a remote branch, or none exists...
  if   [[ -z ${existing} ]] \
    || [[ ${existing} =~ ^(${(j:|:)remotes})/${branch}$ ]]
  then
    # create a new branch tracking the remote branch (if any)
    args=(--track -b ${branch} ${target_path} ${existing})
  else # otherwise, the branch exists locally
    # however no worktree exists, so check it out to ${target_path}
    args=(${target_path} ${branch})
  fi
  # finally, add the new worktree
  print -nf '┯ New worktree\n├ %s\n└ %s\n' \
    "Branch: ${branch}"                    \
    "Path:   ./${target_path##$(git-worktree-root)/}"
  git worktree add ${args[@]}
}

function git-worktree-remove-for-branch {
  local tree=$(git-worktree-find-for-branch ${1})
  if [[ -z ${tree} ]]; then
    print -nf '┯ %s\n└ %s\n'                           \
      'Cannot remove worktree for branch, none exists' \
      "Branch: ${1}"
    return 1
  fi
  git worktree remove ${tree}
  rm -rf ${tree}
}

function git-worktree-default-branch-path {
  local branch=${1}
  print $(git-worktree-root)/${branch}
}

function zwk {
  local root=$(git-worktree-root)
  if [[ -z ${root} ]]; then
    return 1
  fi
  local worktree_paths=($(git-worktree-paths))
  # if a worktree reference is provided, jump to the matching worktree
  if [[ -n ${1} ]]; then
    local match=${worktree_paths[(r)*${1}*]}
    _z -c ${root} ${match}
    return 0
  fi
  # otherwise, launch an interactive worktree selector
  local selected
  print ${(j:\n:)worktree_paths#${root}/}                               \
    | fzf                                                               \
          --reverse                                                     \
          --height 50                                                   \
          --bind 'ctrl-s:toggle-preview'                                \
          --bind 'ctrl-x:execute(print !{remove} {})+accept'            \
          --bind 'ctrl-space:execute(print !cd {})+accept'              \
          --preview 'git --git-dir={}/.git show --format=short --color' \
          --preview-window hidden,up,40                                 \
    | read selected
  if [[ ${selected} =~ '^!(.+)' ]]; then
    print -z ${selected[2,-1]}
    return 0
  elif [[ -n ${selected} && ! ${PWD##${root}/} = ${selected} ]]; then
    cd ${selected}
  fi
}

# given a branch, worktree-create-if-not-exists and then cd into it
function _zwb-default-command {
  local commands=(
    "git-worktree-create-if-not-exists ${1}"
    "cd \$(git-worktree-find-for-branch ${1})"
  )
  print ${(j: && :)commands}
}

function zwb {
  # get the root of the current worktree forest, and if none, bail
  local root=$(git-worktree-root)
  if [[ -z ${root} ]]; then
    return 1
  fi
  # first argument, if given, should be a branch name
  local branch=${1}
  # load all worktrees into an associative array of path->branch
  typeset -A worktree_entries=($(git-worktree-entries))
  # if a branch reference was provided, [create and] jump to its worktree
  if [[ -n ${branch} ]]; then
    local match=${worktree_entries[(r)${branch}]}
    # if a worktree does not exist for the branch, create one and cd in
    eval $(_zwb-default-command ${branch})
    # git-worktree-create-if-not-exists ${branch}
    # cd $(git-worktree-find-for-branch ${branch})
    return 0
  fi
  # otherwise, launch an interactive branch selector
  local selected; _zwb-toggle-list worktree-branches                \
    | fzf                                                           \
          --reverse                                                 \
          --height 50                                               \
          --bind 'ctrl-s:toggle-preview'                            \
          --bind 'ctrl-t:reload(_zwb-toggle-list)'                  \
          --bind 'ctrl-x:execute(print "!{remove} {}")+accept'      \
          --bind 'ctrl-space:execute(print "!{default} {}")+accept' \
          --preview 'git show {} --format=short --color'            \
          --preview-window hidden,50                                \
    | read selected
  # strip remote prefix from selected ref, if any
  local match mbegin mend
  local remotes=($(git remote))
  if [[ ${selected} =~ ^(${(j:|:)remotes})/(.+)$ ]]
  then branch=${match[2]} # strip the remote name, grab the branch name
  else branch=${selected} # otherwise, the whole thing is the branch name
  fi
  # prefixed with '!' means 'print the following command to the prompt'
  if [[ ${branch} =~ '^!(.+) (.+)$' ]]; then
    if [[ ${match[1]} = '{default}' ]]; then
      print -z $(_zwb-default-command ${match[2]})
    elif [[ ${match[1]} = '{remove}' ]]; then
      print -z git-worktree-remove-for-branch ${match[2]}
    fi
  elif [[ -n ${branch} ]]; then
    eval $(_zwb-default-command ${branch})
  fi
}

# typeset -Ag _zwb_lists=(
#   [all-branches]=git-branch-list-porcelain
#   [worktree-branches]=git-worktree-branches
# )

# typeset -g _zwb_current_list_file="${HOME}/.cache/zwb_current_list"
# typeset -g _zwb_current_list=${${(k)_zwb_lists}[1]}
# if [[ -f ${_zwb_current_list_file} ]]; then
#   zwb_current_list=$(<${_zwb_current_list_file})
# fi

# function _zwb-toggle-list {
#   # if a valid key of _zwb_lists was passed, set _zwb_current_list to it
#   if [[ -n ${1} && -n ${_zwb_lists[(i)${1}]} ]]; then
#     _zwb_current_list=${1}
#   fi
#   # check that _zwb_current_list is a valid key of _zwb_lists
#   if [[ -z ${_zwb_lists[(i)${_zwb_current_list}]} ]]; then
#     print -f '┯ Invalid ${_zwb_current_list}\n└ Valid lists: (%s)\n' \
#       "${(k)_zwb_lists}"
#     return 1
#   fi
#   # invoke the list generation function defined at _zwb_current_list
#   ${_zwb_lists[${_zwb_current_list}]}
#   # find the index of the current list by its key name
#   typeset -i index=${${(k)_zwb_lists}[(i)${_zwb_current_list}]}
#   # find the next index, remembering that zsh arrays are 1-indexed
#   typeset -i next_index=$((1 + ${index} % ${#_zwb_lists}))
#   # get the key in the _zwb_lists associative array at the next index
#   typeset next_key=${${(Ak)_zwb_lists}[${next_index}]}
#   # update _zwb_current_list to the next key
#   _zwb_current_list=${next_key}
#   print ${_zwb_current_list} >! ${_zwb_current_list_file}
# }

zmodload zsh/complete

compdef _gitbranches                \
  zwb                               \
  git-worktree-create-if-not-exists \
  git-worktree-find-for-branch

function _gitbranches {
  branches=($(git-branch-list-porcelain))
  _describe 'branch' branches
}

compdef _worktree-paths \
  zwk

function _worktree-paths {
  worktrees=($(git-worktree-paths))
  _describe 'worktree' worktrees
}

compdef _worktree-branches \
  git-worktree-remove-for-branch

function _worktree-branches {
  branches=($(git-worktree-branches))
  _describe 'branch' branches
}

if [[ -n ${precmd_functions[(r)parse-vcs-info__precmd]} ]]; then
  precmd_functions+=(vcs-user__precmd)
fi
